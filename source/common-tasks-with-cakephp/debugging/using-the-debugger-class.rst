4.4.2 Using the Debugger Class
------------------------------

To use the debugger, first ensure that Configure::read('debug') is
set to a value greater than 0.

dump($var)

Dump prints out the contents of a variable. It will print out all
properties and methods (if any) of the supplied variable.

::

        $foo = array(1,2,3);
        
        Debugger::dump($foo);
        
        //outputs
        array(
            1,
            2,
            3
        )
        
        //simple object 
        $car = new Car();
        
        Debugger::dump($car);
        
        //outputs
        Car::
        Car::colour = 'red'
        Car::make = 'Toyota'
        Car::model = 'Camry'
        Car::mileage = '15000'
        Car::acclerate()
        Car::decelerate()
        Car::stop()

log($var, $level = 7)
Creates a detailed stack trace log at the time of invocation. The
log() method prints out data similar to that done by
Debugger::dump(), but to the debug.log instead of the output
buffer. Note your app/tmp directory (and its contents) must be
writable by the web server for log() to work correctly.

trace($options)
Returns the current stack trace. Each line of the trace includes
the calling method, including which file and line the call
originated from.

::

        //In PostsController::index()
        pr( Debugger::trace() );
        
        //outputs
        PostsController::index() - APP/controllers/downloads_controller.php, line 48
        Dispatcher::_invoke() - CORE/cake/dispatcher.php, line 265
        Dispatcher::dispatch() - CORE/cake/dispatcher.php, line 237
        [main] - APP/webroot/index.php, line 84

Above is the stack trace generated by calling Debugger::trace() in
a controller action. Reading the stack trace bottom to top shows
the order of currently running functions (stack frames). In the
above example, index.php called Dispatcher::dispatch(), which
in-turn called Dispatcher::\_invoke(). The \_invoke() method then
called PostsController::index(). This information is useful when
working with recursive operations or deep stacks, as it identifies
which functions are currently running at the time of the trace().

excerpt($file, $line, $context)
Grab an excerpt from the file at $path (which is an absolute
filepath), highlights line number $line with $context number of
lines around it.

::

        pr( Debugger::excerpt(ROOT.DS.LIBS.'debugger.php', 321, 2) );
        
        //will output the following.
        Array
        (
            [0] => <code><span style="color: #000000"> * @access public</span></code>
            [1] => <code><span style="color: #000000"> */</span></code>
            [2] => <code><span style="color: #000000">    function excerpt($file, $line, $context = 2) {</span></code>
    
            [3] => <span class="code-highlight"><code><span style="color: #000000">        $data = $lines = array();</span></code></span>
            [4] => <code><span style="color: #000000">        $data = @explode("\n", file_get_contents($file));</span></code>
        )

Although this method is used internally, it can be handy if you're
creating your own error messages or log entries for custom
situations.

exportVar($var, $recursion = 0)
Converts a variable of any type to a string for use in debug
output. This method is also used by most of Debugger for internal
variable conversions, and can be used in your own Debuggers as
well.

invoke($debugger)
Replace the CakePHP Debugger with a new Error Handler.

4.4.2 Using the Debugger Class
------------------------------

To use the debugger, first ensure that Configure::read('debug') is
set to a value greater than 0.

dump($var)

Dump prints out the contents of a variable. It will print out all
properties and methods (if any) of the supplied variable.

::

        $foo = array(1,2,3);
        
        Debugger::dump($foo);
        
        //outputs
        array(
            1,
            2,
            3
        )
        
        //simple object 
        $car = new Car();
        
        Debugger::dump($car);
        
        //outputs
        Car::
        Car::colour = 'red'
        Car::make = 'Toyota'
        Car::model = 'Camry'
        Car::mileage = '15000'
        Car::acclerate()
        Car::decelerate()
        Car::stop()

log($var, $level = 7)
Creates a detailed stack trace log at the time of invocation. The
log() method prints out data similar to that done by
Debugger::dump(), but to the debug.log instead of the output
buffer. Note your app/tmp directory (and its contents) must be
writable by the web server for log() to work correctly.

trace($options)
Returns the current stack trace. Each line of the trace includes
the calling method, including which file and line the call
originated from.

::

        //In PostsController::index()
        pr( Debugger::trace() );
        
        //outputs
        PostsController::index() - APP/controllers/downloads_controller.php, line 48
        Dispatcher::_invoke() - CORE/cake/dispatcher.php, line 265
        Dispatcher::dispatch() - CORE/cake/dispatcher.php, line 237
        [main] - APP/webroot/index.php, line 84

Above is the stack trace generated by calling Debugger::trace() in
a controller action. Reading the stack trace bottom to top shows
the order of currently running functions (stack frames). In the
above example, index.php called Dispatcher::dispatch(), which
in-turn called Dispatcher::\_invoke(). The \_invoke() method then
called PostsController::index(). This information is useful when
working with recursive operations or deep stacks, as it identifies
which functions are currently running at the time of the trace().

excerpt($file, $line, $context)
Grab an excerpt from the file at $path (which is an absolute
filepath), highlights line number $line with $context number of
lines around it.

::

        pr( Debugger::excerpt(ROOT.DS.LIBS.'debugger.php', 321, 2) );
        
        //will output the following.
        Array
        (
            [0] => <code><span style="color: #000000"> * @access public</span></code>
            [1] => <code><span style="color: #000000"> */</span></code>
            [2] => <code><span style="color: #000000">    function excerpt($file, $line, $context = 2) {</span></code>
    
            [3] => <span class="code-highlight"><code><span style="color: #000000">        $data = $lines = array();</span></code></span>
            [4] => <code><span style="color: #000000">        $data = @explode("\n", file_get_contents($file));</span></code>
        )

Although this method is used internally, it can be handy if you're
creating your own error messages or log entries for custom
situations.

exportVar($var, $recursion = 0)
Converts a variable of any type to a string for use in debug
output. This method is also used by most of Debugger for internal
variable conversions, and can be used in your own Debuggers as
well.

invoke($debugger)
Replace the CakePHP Debugger with a new Error Handler.
